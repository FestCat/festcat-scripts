#!/usr/bin/festival --script
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-*-mode:scheme-*-
;;                                                                       ;;
;;                Centre for Speech Technology Research                  ;;
;;                     University of Edinburgh, UK                       ;;
;;                       Copyright (c) 1996,1997                         ;;
;;                        All Rights Reserved.                           ;;
;;                                                                       ;;
;;  Permission is hereby granted, free of charge, to use and distribute  ;;
;;  this software and its documentation without restriction, including   ;;
;;  without limitation the rights to use, copy, modify, merge, publish,  ;;
;;  distribute, sublicense, and/or sell copies of this work, and to      ;;
;;  permit persons to whom this work is furnished to do so, subject to   ;;
;;  the following conditions:                                            ;;
;;   1. The code must retain the above copyright notice, this list of    ;;
;;      conditions and the following disclaimer.                         ;;
;;   2. Any modifications must be clearly marked as such.                ;;
;;   3. Original authors' names are not deleted.                         ;;
;;   4. The authors' names are not used to endorse or promote products   ;;
;;      derived from this software without specific prior written        ;;
;;      permission.                                                      ;;
;;                                                                       ;;
;;  THE UNIVERSITY OF EDINBURGH AND THE CONTRIBUTORS TO THIS WORK        ;;
;;  DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING      ;;
;;  ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT   ;;
;;  SHALL THE UNIVERSITY OF EDINBURGH NOR THE CONTRIBUTORS BE LIABLE     ;;
;;  FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    ;;
;;  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN   ;;
;;  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,          ;;
;;  ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF       ;;
;;  THIS SOFTWARE.                                                       ;;
;;                                                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;           Author:  Alan W Black
;;;           Date:    November 1997
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;;  Text to a single waveform like festival_client but without
;;;  starting the server
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;         Modified: Sergio Oller <sergioller@gmail.com
;;;             Date: Aug 2011
;;;          Changes: 
;;;                   * Final concatenation using sox (uses less memory)
;;;                   * If voice is HTS, use the festcat_hts_engine
;;;                     to avoid loading HTS models every time.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Because this is a --script type file I has to explicitly
;;; load the initfiles: init.scm and user's .festivalrc
(load (path-append datadir "init.scm"))

;;; Process command line arguments
(define (text2wave_help)
  (format t "%s\n"
  "festcat-text2wave [options] textfile
  Convert a textfile to a waveform
  Options
  -mode <string>  Explicit tts mode.
  -o ofile        File to save waveform (default is stdout).
  -eval <string>  File or lisp s-expression to be evaluated before
                  synthesis.
")
  (quit))

;;; No gc messages
(gc-status nil)

;;; Default argument values
(defvar outfile "audio.ogg")
(defvar text_files '("-"))
(defvar mode nil)
(defvar labelfiles nil)
(defvar wavefiles nil)

;;; Get options
(define (get_options)

  (let ((files nil)
	(o argv))
    (if (or (member_string "-h" argv)
	    (member_string "-help" argv)
	    (member_string "--help" argv)
	    (member_string "-?" argv))
	(text2wave_help))
    (while o
      (begin
	(cond
	 ((string-equal "-o" (car o))
	  (if (not (cdr o))
	      (text2wave_error "no output file specified"))
	  (set! outfile (car (cdr o)))
	  (set! o (cdr o)))
	 ((string-equal "-mode" (car o))
	  (if (not (cdr o))
	      (text2wave_error "no mode specified"))
	  (set! mode (car (cdr o)))
	  (set! o (cdr o)))
	 ((string-equal "-eval" (car o))
	  (if (not (cdr o))
	      (text2wave_error "no file specified to load"))
	  (if (string-matches (car (cdr o)) "^(.*")
	      (eval (read-from-string (car (cdr o))))
	      (load (car (cdr o))))
	  (set! o (cdr o)))
	 (t
	  (set! files (cons (car o) files))))
	(set! o (cdr o))))
    (if files
	(set! text_files (reverse files)))))

(define (text2wave_error message)
  (format stderr "%s: %s\n" "text2wave" message)
  (text2wave_help))


(define (open_label utt)
"Saves the waveform and records its so it can be joined into a 
a single waveform at the end."
  (let ((fn (make_tmp_filename)))
    (set! SaveLabel_fp (fopen fn "w"))
    (Param.set 'Synth_Method "HTSLABEL")
    (set! labelfiles (cons fn labelfiles))
    utt))

(define (close_label utt)
(fclose SaveLabel_fp)
)

(define (combine_waves_hts)
  "Join all the waves together into the desired output file
and delete the intermediate ones."
  (let ( (guifn (make_tmp_filename))
         (guifd nil)
         (rawfn (string-append (make_tmp_filename) ".raw" ))
         (tmpargs hts_engine_params)
         (festcat-hts-engine "__BINDIR__/festcat_hts_engine")
         (htscommand "")
       )
    (set! guifd (fopen guifn "w"))
    (mapcar
     (lambda (d)
       (format guifd "%s\n" d)
     )
     (reverse labelfiles)
    )
    (fclose guifd)
    (while (car tmpargs)
      (set! htscommand (string-append htscommand " " (caar tmpargs) " " (car (cdar tmpargs))))
      (set! tmpargs (cdr tmpargs))
    )
    (set! htscommand (string-append festcat-hts-engine " " htscommand " -or " rawfn " " guifn))
    (system htscommand)
    (while (car labelfiles)
      (delete-file (car labelfiles))
      (set! labelfiles (cdr labelfiles))
    )
    (delete-file guifn)
    (system (string-append "sox -r 16000 -c 1 -e signed -b 16 " rawfn " " outfile))
    (delete-file rawfn)
  )
)

(define (save_record_wave utt)
"Saves the waveform and records its so it can be joined into a 
a single waveform at the end."
  (let ((fn (make_tmp_filename)))
    (utt.save.wave utt fn )
    (set! wavefiles (cons fn wavefiles))
    utt)
)

(define (combine_waves_nohts)
  "Join all the waves together into the desired output file
and delete the intermediate ones."
  (let ( (rawfn (make_tmp_filename))
         (firsttime t)
       )
    (mapcar
     (lambda (d)
       (system (string-append "sox " d "-r 16000 -c 1 -e signed -b 16 " d ".raw"))
       (if (firsttime)
            (system (string-append "cat " d ".raw > " rawfn))
            (system (string-append "cat " d ".raw >> " rawfn))
       )
       (set! firsttime nil)
       (delete-file d)
     )
     (reverse wavefiles)
    )
    (system (string-append "sox -r 16000 -c 1 -e signed -b 16 " rawfn " " outfile))
  )
)

;;;
;;; Redefine what happens to utterances during text to speech 
;;;
(require "__DATADIR__/htslabel")

(define (main)
  (get_options)
  (if (string-matches (string-append current-voice) ".*hts.*")
     (begin
      (set! tts_hooks (list open_label utt.synth close_label))
      ;; generate labels
      (mapcar
       (lambda (f) 
        (if mode
          (tts_file f mode)
	  (tts_file f (tts_find_text_mode f auto-text-mode-alist))))
        text_files)

     ;; synthesize
      (combine_waves_hts)
     )
     (begin 
      (set! tts_hooks (list utt.synth save_record_wave))
      ;; generate labels
      (mapcar
       (lambda (f) 
        (if mode
          (tts_file f mode)
	  (tts_file f (tts_find_text_mode f auto-text-mode-alist))))
        text_files)

     ;; synthesize
      (combine_waves_nohts)
     )
  )
)

;;;  Do the work
(main)
